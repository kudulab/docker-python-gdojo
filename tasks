#!/bin/bash

set -e
if [[ ! -f ./releaser ]]; then
  wget --quiet http://http.archive.ai-traders.com/releaser/1.1.0/releaser || { echo "Cannot download releaser, ignoring."; }
fi
if [[ -f ./releaser ]]; then
  source ./releaser
fi
if [[ ! -f ./docker-ops ]]; then
  wget --quiet http://http.archive.ai-traders.com/docker-ops/0.3.3/docker-ops || { echo "Cannot download docker-ops, ignoring."; }
fi
if [[ -f ./docker-ops ]]; then
  source ./docker-ops
fi

image_name="python2-gide"
image_dir="./image"
imagerc_basename="imagerc"
image_registry="docker-registry.ai-traders.com"

function base_ide_last_tag {
  git ls-remote --tags git@git.ai-traders.com:stcdev/docker-python2-ide.git | sort -t '/' -k 3 -V | awk '{print $2}' | cut -d'/' -f3 | tail -1
}

function build {
  prefix=$1
  base_img_version=$(base_ide_last_tag)
  base_img_tag=$prefix-$base_img_version
  image_tag=$prefix-$(git rev-parse HEAD)
  sed "s/{{BASE_IMAGE_VERSION}}/${base_img_tag}/g" image/Dockerfile.tmpl > image/Dockerfile.$prefix
  ( set -x; cd "${image_dir}"; docker build -f Dockerfile.$prefix -t "${image_name}:${image_tag}" .; )
  docker_ops::create_imagerc "${image_dir}" "${imagerc_basename}.${prefix}" "${image_name}" "${image_tag}" "${image_registry}"
  docker_ops::push_tmp "${image_name}" "${image_tag}" "${image_registry}"
}

function itest {
  prefix=$1
  set -e
  docker_ops::ensure_temp_image "${image_dir}" "${imagerc_basename}.${prefix}"
  echo "Testing image: ${AIT_DOCKER_IMAGE_URL}"
  echo "DOJO_DOCKER_IMAGE=\"${AIT_DOCKER_IMAGE_URL}\"" > ./Dojofile.to_be_tested
  echo "DOJO_IDENTITY_OUTER=\"$(pwd)/test/integration/identities/full\"" >> ./Dojofile.to_be_tested
  echo "DOJO_WORK_OUTER=$(pwd)/test/integration/end_user/test_dojo_work" >> ./Dojofile.to_be_tested
  time bats "$(pwd)/test/integration/end_user/bats"
}

function publish {
  prefix=$1
  base_img_version=$(base_ide_last_tag)
  gide_img_version=$(get_last_version_from_changelog "${changelog_file}")
  production_image_tag="$prefix-${gide_img_version}_${base_img_version}"
  docker_ops::push_production "${image_dir}" "${imagerc_basename}.${prefix}" "${image_name}" "${production_image_tag}" "${image_registry}"
}

command="$1"
case "${command}" in
  set_version)
      if [[ -n "$2" ]]; then
        next_version="$2"
      else
        version=$(releaser::get_last_version_from_whole_changelog "${changelog_file}")
        next_version=$(releaser::bump_patch_version "${version}")
      fi
      releaser::set_version_in_changelog "${changelog_file}" "${next_version}"
      exit $?
      ;;
  verify_version)
      # conditional verify
      git fetch origin
      current_commit_git_tags=$(git tag -l --points-at HEAD)
      if [[ "${current_commit_git_tags}" != "" ]];then
        log_info "Current commit is already tagged"
      else
        log_info "Current commit has no tags, full verify_version"
        releaser::verify_changelog_version
      fi
      exit $?
      ;;
  build_py27)
      build "py27"
      exit $?
      ;;
  build_py35)
      build "py35"
      exit $?
      ;;
  itest_py27)
      itest "py27"
      exit $?
      ;;
  itest_py35)
      itest "py35"
      exit $?
      ;;
  code_release)
      # conditional release
      git fetch origin
      current_commit_git_tags=$(git tag -l --points-at HEAD)
      if [[ "${current_commit_git_tags}" != "" ]];then
        log_info "Current commit is already tagged, skipping code release"
      else
        log_info "Current commit has no tags, starting code release..."
        ./tasks verify_version
        version=$(releaser::get_last_version_from_whole_changelog "${changelog_file}")
        git tag "${version}" && git push origin "${version}"
      fi
      exit $?
      ;;
  publish_py27)
      publish "py27"
      exit $?
      ;;
  publish_py35)
      publish "py35"
      exit $?
      ;;
  *)
      echo "Invalid command: '${command}'"
      exit 1
      ;;
esac
set +e
